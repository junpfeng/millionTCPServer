# millionTCPServer

## 网络数据包

### 基本包格式

报文有两部分：`包头`和`包体`

* 包头：描述本次数据包的大小等信息
* 包体：具体的数据

### 常见问题

定长数据/变长数据、粘包/分包

* **变长数据**：

* **粘包**：多个数据包由于各种原因被接收端一起接受成了一个大包，就像多个数据包粘在一起。此时，就需要根据包头定义的数据长度进行拆包。

* **分包**：当某个数据过长，被分为多个包发送，接收端要接受完所有分包的数据。

* **接受缓冲区溢出**

  当内核的处理网络数据赶不上接收网络数据时，就会出现内核的接受缓冲区溢出的情况；

  * **解决方案一：双缓冲区**

    一旦收到消息，就将数据从内核缓冲区全部取出，放到内存/硬盘中，从而保证内核缓冲区不会溢出。

* 动态多态时，使用引用传参还是指针传参的问题

  如果考虑跨平台和高兼容性，选择指针；因为引用的底层实现，在不同平台是不一样的，也许会发送不兼容的情况。

  但是指针的操作常常会引起内存泄漏，从安全性角度考虑，使用引用。

  综上，就是指针优先。

### 双数据缓冲区设计

#### 服务端设计

* 服务端需要为每个连接的客户端都单独建立一个第二缓冲区。
* 计算机的内存分布中，栈空间相比于堆空间而言较小，对于这种较大的缓冲区，需要使用堆区的内存，对应了`new`和`malloc`。

### 粘包与解包

## problems

### 粘包？？？

有一种说法是`粘包`这个概念是个伪命题，因为在英文原版的相关资料中，从未出现`粘包`这个词。

* 一般意义上所谓的`粘包`是指不相干的几个数据段连续存放，这些数据段都是`应用层`人为划分的。因此`粘包`是存在于`应用层`的的一个伪命题。
* `TCP`传输是面向`字节流`的，所以在`TCP`里实际上并没有`包`的概念，所谓的`TCP`的数据包，实际上应该叫`TCP`的数据帧。
* 解决所谓的`粘包`的思想其实也比较简单，当然这些都是基于`应用层`的解决方案；一个方法就是对每个独立所谓的`包`设置一个包头，包头的长度是手法双发约定的，包头中纪录了一个包的长度，从而指导接收端划分出一个独立的包，这个过程也被称为`解包`。

### 解决粘包时，一个小疏忽耽误了我一天的时间

在处理完一个独立的数据段后，应该将第二缓冲区向前移位，但我将第二缓冲区变成了接收缓冲区，

## 修改 windows 下select的最大连接数量

```c
#define FD_SETSIZE 1024
// 一般不要超过1024，超过了那就使用epoll好了
// windows修改select连接上限非常简单，但是linux则需要修改内核才行。

```

## TIME_WAIT 和 CLOSE_WAIT 问题

`TIME_WAIT`是主动发起关闭的一方会进入的状态、`CLOSE_WAIT`是被动关闭的一方会进入的状态。

使用centos测试TCP通信时发现，在客户端主动关闭后，服务器会长时间保持close_wait的状态。

### CLOSE_WAIT且一直不变的原因

服务器和客户端的代码有问题：客户端主动发起关闭`close(socket)`后，此时会进入半关闭状态，需要等待服务器回应`close(socket)`；如果服务器程序中没有`close(socket)`，就会一直处于`CLOSE_WAIT`状态；这会导致端口一些资源被占用，如果过多的`TIME_WAIT`会导致服务器崩溃。`TIME_WAIT`最长保持2个小时。

