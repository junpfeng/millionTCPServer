# millionTCPServer

## 网络数据包

### 基本包格式

报文有两部分：`包头`和`包体`

* 包头：描述本次数据包的大小等信息
* 包体：具体的数据

### 常见问题

定长数据/变长数据、粘包/分包

* **变长数据**：

* **粘包**：多个数据包由于各种原因被接收端一起接受成了一个大包，就像多个数据包粘在一起。此时，就需要根据包头定义的数据长度进行拆包。
<<<<<<< HEAD
<<<<<<< HEAD
* **分包**：当某个数据过长，被分为多个包发送，接收端要接受完所有分包的数据。

**select 无法监测到事件**  
* 检查`select`函数的第一个参数是否正确，需要为监测事件中最大文件描述符 + 1
=======
=======
>>>>>>> 10904bc... fix msg package recv #1

* **分包**：当某个数据过长，被分为多个包发送，接收端要接受完所有分包的数据。

* **接受缓冲区溢出**

  当内核的处理网络数据赶不上接收网络数据时，就会出现内核的接受缓冲区溢出的情况；

  * **解决方案一：双缓冲区**

    一旦收到消息，就将数据从内核缓冲区全部取出，放到内存/硬盘中，从而保证内核缓冲区不会溢出。

* 动态多态时，使用引用传参还是指针传参的问题

  如果考虑跨平台和高兼容性，选择指针；因为引用的底层实现，在不同平台是不一样的，也许会发送不兼容的情况。

  但是指针的操作常常会引起内存泄漏，从安全性角度考虑，使用引用。

  综上，就是指针优先。

### 双数据缓冲区设计

#### 服务端设计

* 服务端需要为每个连接的客户端都单独建立一个第二缓冲区。
* 计算机的内存分布中，栈空间相比于堆空间而言较小，对于这种较大的缓冲区，需要使用堆区的内存，对应了`new`和`malloc`。

### 粘包与解包

## problems

### 粘包？？？

有一种说法是`粘包`这个概念是个伪命题，因为在英文原版的相关资料中，从未出现`粘包`这个词。

* 一般意义上所谓的`粘包`是指不相干的几个数据段连续存放，这些数据段都是`应用层`人为划分的。因此`粘包`是存在于`应用层`的的一个伪命题。
* `TCP`传输是面向`字节流`的，所以在`TCP`里实际上并没有`包`的概念，所谓的`TCP`的数据包，实际上应该叫`TCP`的数据帧。
* 解决所谓的`粘包`的思想其实也比较简单，当然这些都是基于`应用层`的解决方案；一个方法就是对每个独立所谓的`包`设置一个包头，包头的长度是手法双发约定的，包头中纪录了一个包的长度，从而指导接收端划分出一个独立的包，这个过程也被称为`解包`。

<<<<<<< HEAD
>>>>>>> 10904bc... fix msg package recv #1
=======
>>>>>>> 10904bc... fix msg package recv #1
